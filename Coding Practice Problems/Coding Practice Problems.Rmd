---
title: "Competitive Coding Practice Problems"
author: "Kevin Patyk"
date: "11/8/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Competitive Coding Practice Problems from CodeChef

-----

# 1 - ATM

Pooja would like to withdraw X USD from an ATM. The cash machine will only accept the transaction if X is a multiple of 5, and Pooja's account balance has enough cash to perform the withdrawal transaction (including bank charges). For each successful withdrawal the bank charges 0.50 $US. Calculate Pooja's account balance after an attempted transaction.

* Input: Positive integer 0 < X <= 2000 - the amount of cash which Pooja wishes to withdraw. Nonnegative number 0<= Y <= 2000 with two digits of precision - Pooja's initial account balance. 

* Output: Output the account balance after the attempted transaction, given as a number with two digits of precision. If there is not enough money in the account to complete the transaction, output the current bank balance.
```{r}
atm <- function(x, y){
  if(x %% 5 == 0){
    withdrawal <- y - x
    final <- round(withdrawal - 0.50, 2)
  } else {
    stop("x must be a multiple of 5")
  }
  if (x > y){
    stop(paste("Insufficient funds for withdrawal. You only have", y, "but you requested", x))
  }
  balance <- paste("Your remaining balance is:", y - final)
  return(list("Withdrawal Amount" = final, "Balance" = balance))
}

atm(x = 100, y = 120)
```

# 2 - Add Two Numbers

Shivam is the youngest programmer in the world, he is just 12 years old. Shivam is learning programming and today he is writing his first program.

The task is very simple: given two integers A and B, write a program to add these two numbers and output it.

* Input: The first line contains an integer T, the total number of test cases. Then follow T lines, each line contains two Integers A and B.

* Output: For each test case, add A and B and display the sum in a new line.

* Constraints: 1 ≤ T ≤ 1000, 0 ≤ A,B ≤ 10000
```{r}
addnums <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 0, b >= 0, a <= 10000, b <= 10000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    stor[[i]] <- a[i] + b[i]
  }
  return(stor)
}

addnums(len_t = 3, a = c(1,2,3), b = c(1,2,3))
```

# 3 - Number Mirror

Write a program that accepts a number, n, and outputs the same.

* Input: The only line contains a single integer.

* Output: Output the answer in a single line.

* Constraints: 0 ≤ n ≤ 105
```{r}
mirror <- function(n){
  stopifnot(length(n) == 1)
  if(n <= 0 | n >= 10^5){
    stop("n is not within the constraints") 
  }  else {
    print(n)
  }
}

mirror(n = 1)
```

# 4 - Sum of Digits

You're given an integer N. Write a program to calculate the sum of all the digits of N.

* Input: The first line contains an integer T, the total number of testcases. Then follow T lines, each line contains an integer N.

* Output: For each test case, calculate the sum of digits of N, and display it in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000

Here we are using: `sum(as.numeric(strsplit(x = as.character(n), split = "")[[1]]))`. This code will:

* First, it will coerce the number vector into a character vector.
* Then, it will split the character vector into separate parts. This will turn it into a list. 
* Then, it will subset the list using the first index, which will give us the numbers as splits characters.
* Finally, the numbers will be coerced into a numeric type and summed. 
```{r}
sumdigits <- function(len_t, n){
  stopifnot(len_t > 0, len_t < 1000, n > 0, n < 1000000)
  x <- lapply(X = n, FUN = function(x) sum(as.numeric(strsplit(x = as.character(n), split = "")[[1]])))
  print(x)
}

sumdigits(len_t = 3, n = c(123,123,123))

#using for loop instead of lapply()
sumdigits_for <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 1, n <= 1000000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){ 
    stor[[i]] <- sum(as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]]))
  }
  return(stor)
}

sumdigits_for(len_t = 3, n = c(123,123,123))
```

# 5 - Find Remainder

Write a program to find the remainder when an integer A is divided by an integer B.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains two Integers A and B.

* Output: For each test case, find the remainder when A is divided by B, and display it in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B ≤ 10000
```{r}
remainder <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 0, b >= 0, a <= 10000, b <= 10000)
  stor <- list(1:len_t)
  for(i in 1:len_t){
    stor[[i]] <- a[i] %% b[i]
  }
  return(stor)
}

remainder(len_t = 3, a = c(10,5,3), b = c(6,4,2))
```

# 6 - First and Last Digit 

If Give an integer N . Write a program to obtain the sum of the first and last digits of this number.

* Input: The first line contains an integer T, the total number of test cases. Then follow T lines, each line contains an integer N.

* Output: For each test case, display the sum of first and last digits of N in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000
```{r}
firlasdig <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 1, n <= 1000000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    split <- as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]])
    stor[[i]] <- (split[1] + split[length(split)])
  }
  return(stor)
}

firlasdig(len_t = 3, n = c(123, 123, 123))
```

Instead of `x[length(x)]`, we can also do:

* `tail(x, n=1)`
* `x[end(x)][1]`
* `rev(x)[1]`

# 7 - Lucky Four

Kostya likes the number 4 much. Of course! This number has such a lot of properties.

Impressed by the power of this number, Kostya has begun to look for occurrences of four anywhere. He has a list of T integers, for each of them he wants to calculate the number of occurrences of the digit 4 in the decimal representation. He is too busy now, so please help him.

* Input: The first line of input consists of a single integer T, denoting the number of integers in Kostya's list.
Then, there are T lines, each of them contain a single integer from the list.

* Output: Output T lines. Each of these lines should contain the number of occurences of the digit 4 in the respective integer from Kostya's list.

* Constraints: 1 ≤ T ≤ 10^5
```{r}
luckyfour <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 10^5)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
  split <- as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]])
  stor[[i]] <- length(split[split == 4])
  }
  return(stor)
}

luckyfour(len_t = 4, n = c(1234, 445566, 7444, 555))
```

# 8 - Small Factorials

You are asked to calculate factorials of some small positive integers.

* Input: An integer t, 1 <= t <= 100, denoting the number of test cases, followed by t lines, each containing a single integer n, 1 <= n <= 100.

* Output: For each integer n given at input, display a line with the value of n!
```{r}
smallfac <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 100, n >= 1, n <= 100)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    stor[[i]] <- factorial(n[i])
  }
  return(stor)
}

smallfac(len_t = 5, n = c(4,1,2,5,3))
```

# 9 - Turbo Sort

Given the list of numbers, you are to sort them in non decreasing order.

* Input: t – the amount of numbers in list, then t lines follow [t <= 10^6]. Each line contains one integer: 0 <= n <= 10^6

* Output: Output given numbers in non decreasing order.
```{r}
turbosort <- function(len_t, n){
  stopifnot(len_t <= 10^6, n >= 0, n <= 10^6)
  stor <- list()[1:len_t]
  sorted <- sort(n)
  for(i in 1:len_t){
    stor[[i]] <- sorted[i]
  }
  return(stor)
}

turbosort(len_t = 6, c(6,3,2,4,5,1))
```

# 10 - Reverse the Number

Given an Integer N, write a program to reverse it.

* Input: The first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer N.

* Output: For each test case, display the reverse of the given number N in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000
```{r}
reverseint <- function(len_t, n){
  stopifnot(len_t >= 1,len_t <= 1000, n >= 0, n <= 1000000)
  stor <- list()[1:len_t]
  for(i in 1:len_t){
    split <- as.numeric(strsplit(x = as.character(n[i]), split = "")[[1]])
    stor[[i]] <- as.numeric(paste(rev(split), collapse = ""))
  }
  return(stor)
}

reverseint(len_t = 3, n = c(123,123,123))
```

# 11 - Finding Square Roots

Assume that you happen to hear the above words and you want to give a try in finding the square root of any given integer using in-built functions. So here's your chance.

* Input: The first line of the input contains an integer T, the number of test cases. T lines follow. Each line contains an integer N whose square root need to be computed.

* Output: For each line of the input, output the square root of the input integer, rounded down to the nearest integer, in a new line.

* Constraints: 1<=T<=20, 1<=N<=10000
```{r}
fsq <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 20, n >= 1, n <= 10000)
  stor <- list()
  for(i in 1:len_t){
    stor[[i]] <- floor(sqrt(n[i]))
  }
  return(stor)
}

fsq(len_t = 4, n = c(3, 10, 5, 10000))
```

# 12 - Second Largest

Three numbers A, B and C are the inputs. Write a program to find second largest among them.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains three integers A, B and C.

* Output: For  each test case, display the second largest among A, B and C, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B,C ≤ 1000000
```{r}
seclarg <- function(len_t, a, b, c){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 1, b >= 1, c >= 1, a <= 1000000, b <= 1000000, c <= 1000000)
  stor <- list()
  for(i in 1:len_t){
    vec <- sort(c(a[i], b[i], c[i]))
    stor[[i]] <- vec[which.max(vec) - 1]
  }
  return(stor)
}

seclarg(len_t = 3, a = c(5,5,5), b = c(1,1,1), c = c(100, 100, 100))
```

# 13 - The Lead Game

* Input: The first line of the input will contain a single integer N (N ≤ 10000) indicating the number of rounds in the game. Lines 2,3,...,N+1 describe the scores of the two players in the N rounds. Line i+1 contains two integer Si and Ti, the scores of the Player 1 and 2 respectively, in round i. You may assume that 1 ≤ Si ≤ 1000 and 1 ≤ Ti ≤ 1000.

* Output: Your output must consist of a single line containing two integers W and L, where W is 1 or 2 and indicates the winner and L is the maximum lead attained by the winner.
```{r}
leadgame <- function(n, p1, p2){
  cumscorep1 <- cumsum(p1)
  cumscorep2 <- cumsum(p2)
  diffp1 <- cumscorep1 - cumscorep2
  diffp2 <- cumscorep2 - cumscorep1
  if(max(diffp1) > max(diffp2)){
  return(c(1, max(diffp1)))  
  } else {
  return(c(2, max(diffp2)))
  }
}

leadgame(n = 5, p1 = c(140, 89, 90, 112, 88), p2 = c(82, 133, 110, 106, 90))
```

# 14 - Helping Chef

Write a program, which takes an integer N and if the number is less than 10 then display "Thanks for helping Chef!" otherwise print "-1".

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains an integer N.

* Output: For each test case, output the given string or -1 depending on conditions, in a new line.

* Constraints: 1 ≤ T ≤ 1000, -20 ≤ N ≤ 20
```{r}
helpchef <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= -20, n <= 20)
  for(i in 1:len_t){
  if(n[i] < 10){
    print("Thanks for helping Chef!")
  } else{
    print("-1")
    }
  }
}

helpchef(len_t = 3, n = c(-10, 19, 5))
```

# 15 - Chef and Operators

Chef has just started Programming, he is in first year of Engineering. Chef is reading about Relational Operators.
Relational Operators are operators which check relationship between two values. Given two numerical values A and B you need to help chef in finding the relationship between them that is,

* First one is greater than second or,
* First one is less than second or,
* First and second one are equal.

* Input: First line contains an integer T, which denotes the number of testcases. Each of the T lines contain two integers A and B

* Output: For each line of input produce one line of output. This line contains any one of the relational operators
'<' , '>' , '='.

* Constraints: 1 ≤ T ≤ 10000, 1 ≤ A, B ≤ 1000000001
```{r}
chefop <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 10000, a >= 1, a <= 1000000001, b >= 1, b <= 1000000001)
  for(i in 1:len_t){
    if(a[i] > b[i]){
      print(">")
    } else if(a[i] < b[i]){
      print("<")
    } else{
      print("=")
    }
  }
}

chefop(len_t = 3, a = c(10,20,10), b = c(20,10,10))
```

# 16 - Packaging Cupcakes

Now that Chef has finished baking and frosting his cupcakes, it's time to package them. Chef has N cupcakes, and needs to decide how many cupcakes to place in each package. Each package must contain the same number of cupcakes. Chef will choose an integer A between 1 and N, inclusive, and place exactly A cupcakes into each package. Chef makes as many packages as possible. Chef then gets to eat the remaining cupcakes. Chef enjoys eating cupcakes very much. Help Chef choose the package size A that will let him eat as many cupcakes as possible.

* Input: Input begins with an integer T, the number of test cases. Each test case consists of a single integer N, the number of cupcakes.

* Output: For each test case, output the package size that will maximize the number of leftover cupcakes. If multiple package sizes will result in the same number of leftover cupcakes, print the largest such size.

* Constraints: 1 ≤ T ≤ 1000, 2 ≤ N ≤ 100000000 (10^8)
```{r}
packcup <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 2, n <= 10^8)
  for(i in 1:len_t){
    print(n[i] %/% 2+1)
  }
}

#%/% is integer division, the same as floor(n/m) - integer division discards the remainder; %% is the remainder  

packcup(len_t = 2, n = c(2,5))
```

# 17 - Valid Triangles

Write a program to check whether a triangle is valid or not, when the three angles of the triangle are the inputs. A triangle is valid if the sum of all the three angles is equal to 180 degrees.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains three angles A, B and C, of the triangle separated by space.

* Output: For each test case, display 'YES' if the triangle is valid, and 'NO', if it is not, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B,C ≤ 180
```{r}
validtri <- function(len_t, a, b, c){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 1, a <= 180, b >= 1, b <= 180, c >= 1, c <= 180)
  for(i in 1:len_t){
  if(sum(a[i] + b[i] + c[i]) > 180){
    print("NO")
  } else {
    print("Yes")
    }
  }
}

validtri(len_t = 3, a = c(40, 45, 180), b = c(40, 45, 1), c = c(100, 90, 1))
```

# 18 - Chef and Remissness 

The office where the Chef works, has two guards who count how many times a person enters into the office building. Though the duty of a guard is 24 hours in a day, sometimes they fall asleep during their duty and do not track the entry of a person in the office building. But one good thing is that they never fall asleep at the same time. At least one of them remains awake and counts who enters into the office.


Now the boss of Chef wants to calculate how many times the Chef has entered into the building. The boss asked to the guard and they gave him two integers A and B, the count of first guard and second guard respectively.


Help the boss to count the minimum and maximum number of times Chef could have entered into the office building.

* Input: The first line of the input contains an integer T denoting the number of test cases. The description of the T test cases follows.

Each test case consists of a line containing two space separated integers A and B.

* Output: For each test case, output a single line containing two space separated integers, the minimum and maximum number of times Chef could have entered into the office building.

* Constraints: 1 ≤ T ≤ 100, 0 ≤ A, B ≤ 1000000
```{r}
chefremiss <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 100, a >= 0, b >= 0, a <= 1000000, b <= 1000000)
  for(i in 1:len_t){
    print(c(a[i], a[i]+ b[i]))
  }
}

chefremiss(len_t = 3, a = c(19, 14, 17), b = c(17, 14, 10))
```

# 19 - Decrement or Increment 

Write a program to obtain a number N and increment its value by 1 if the number is divisible by 4 otherwise decrement its value by 1.

* Input: First line will contain a number N.

* Output: Output a single line, the new value of the number.

* Constraints:0 ≤ N ≤ 1000
```{r}
decorin <- function(n){
  stopifnot(n >= 0, n <= 1000)
  if(n %% 4 == 0){
    print(n + 1)
  } else {
    print(n - 1)
  }
}

decorin(n = 5)
```

# 20 - Mahasena 

Kattapa, as you all know was one of the greatest warriors of his time. The kingdom of Maahishmati had never lost a battle under him (as army-chief), and the reason for that was their really powerful army, also called as Mahasena.

Kattapa was known to be a very superstitious person. He believed that a soldier is "lucky" if the soldier is holding an even number of weapons, and "unlucky" otherwise. He considered the army as "READY FOR BATTLE" if the count of "lucky" soldiers is strictly greater than the count of "unlucky" soldiers, and "NOT READY" otherwise.

Given the number of weapons each soldier is holding, your task is to determine whether the army formed by all these soldiers is "READY FOR BATTLE" or "NOT READY".

* Input: The first line of input consists of a single integer N denoting the number of soldiers. The second line of input consists of N space separated integers A1, A2, ..., AN, where Ai denotes the number of weapons that the ith soldier is holding

* Output: Generate one line output saying "READY FOR BATTLE", if the army satisfies the conditions that Kattapa requires or "NOT READY" otherwise (quotes for clarity)

* Constraints: 1 ≤ N ≤ 100, 1 ≤ Ai ≤ 100
```{r}
battle <- function(n = a, a){
  stopifnot(n >= 1, n <= 100, a >= 1, a <= 100)
  if(sum(a %% 2 == 0) > sum(a %% 2 != 0)){
    print("READY FOR BATTLE")
  } else {
    print("NOT READY")
  }
}

battle(a = c(11:14))
```

# 21 - Sum or Difference

Write a program to take two numbers as input and print their difference if the first number is greater than the second number otherwise print their sum.

* Input: First line will contain the first number (N1), Second line will contain the second number (N2)

* Output: Output a single line containing the difference of 2 numbers (N1−N2) if the first number is greater than the second number otherwise output their sum (N1+N2).

* Constraints: −1000 ≤ N1 ≤ 1000, −1000 ≤ N2 ≤ 1000
```{r}
sumdiff <- function(n1, n2){
  stopifnot(n1 >= -1000, n1 <= 1000, n2 >= -1000, n2 <= 1000)
  if(n1 > n2){
    print(n1 - n2)
  } else{
    print(n1 + n2)
  }
}

sumdiff(n1 = 82, n2 = 28)
```

# 22 - Smallest Numbers of Notes

Consider a currency system in which there are notes of six denominations, namely, Rs. 1, Rs. 2, Rs. 5, Rs. 10, Rs. 50, Rs. 100. If the sum of Rs. N is input, write a program to computer smallest number of notes that will combine to give Rs. N.

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains an integer N

* Output: For each test case, display the smallest number of notes that will combine to give N, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ N ≤ 1000000
```{r}
snn <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000, n >= 1, n <= 1000000)
  den <- c(100, 50, 10, 5, 2, 1)
  x <- numeric()
  for(i in 1:length(n)){ #first for loop to run the same number of times as length n 
  n[i] <- n[i] #this will make a vector containing the n values
  x[i] <- 0 #this will make a vector containing 0s and the same length as the vector of n values - it will end up holding how many notes go into a particular number 
  for(j in 1:length(den)){ #now we will make a for loop to iterate over the den vector - will iterate 6 times
  x[i] <- x[i] + (n[i] %/% den[j]) #how many times the denomination goes into n - so, if 100 goes into 242 2 times, it will store this in the x vector 
  n[i] <- n[i] %% den[j] #the remainder of n after removing the previous denomination - so, if 100 goes into 242 2 times, that is 242 - 100, so 42 will be the new n
}
  }
  return(x)
}

snn(len_t = 3, n = c(1200, 500, 242))
```

# 23 - The Block Game

The citizens of Byteland regularly play a game. They have blocks each denoting some integer from 0 to 9. These are arranged together in a random manner without seeing to form different numbers keeping in mind that the first block is never a 0. Once they form a number they read in the reverse order to check if the number and its reverse is the same. If both are same then the player wins. We call such numbers palindrome.

Ash happens to see this game and wants to simulate the same in the computer. As the first step he wants to take an input from the user and check if the number is a palindrome and declare if the user wins or not.

* Input: The first line of the input contains T, the number of test cases. This is followed by T lines containing an integer N.

* Output: For each input output "wins" if the number is a palindrome and "loses" if not, in a new line.

* Constraints: 1<=T<=20, 1<=N<=20000
```{r}
palindrome <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 20, n >= 1, n <= 20000)
  stor <- list()
  for(i in 1:len_t){
    if(identical(as.character(n[i]), paste(rev(strsplit(as.character(n[i]), "")[[1]]), collapse= ""))){
      stor[[i]] <- "wins"
    } else{
      stor[[i]] <- "loses"
    }
  }
    return(stor)
}

palindrome(len_t = 3, n = c(331, 666, 343))
```

# 24 - Primality Test

Alice and Bob are meeting after a long time. As usual they love to play some math games. This times Alice takes the call and decides the game. The game is very simple, Alice says out an integer and Bob has to say whether the number is prime or not. Bob as usual knows the logic but since Alice doesn't give Bob much time to think, so Bob decides to write a computer program.

Help Bob accomplish this task by writing a computer program which will calculate whether the number is prime or not .

* Input: The first line of the input contains an integer T, the number of test cases. T lines follow. Each of the next T lines contains an integer N which has to be tested for primality. 

* Output: For each test case output in a separate line, "yes" if the number is prime else "no."

* Constraints: 1 ≤ T ≤ 20, 1 ≤ N ≤ 100000
```{r}
# & and && indicate logical AND and | and || indicate logical OR. The shorter form performs element wise comparisons in much the same way as arithmetic operators. The longer form evaluates left to right examining only the first element of each vector. Evaluation proceeds only until the result is determined.
primecheck <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 20, n >= 1, n <= 100000)
  stor <- list()
  for(i in 1:len_t){
    if(n[i] <= 1 | n[i] %% 2 == 0 | n[i] %% 3 == 0){
      stor[[i]] <- "no"
    } else if( n[i] == 2 | n[i] == 3 | n[i] == 5 | n[i] == 7){
      stor[[i]] <- "yes"
    } else{
      for(j in c(2, (n %/% 2) + 1)){
        if(n[i] %% j == 0){
          stor[[i]] <- "no"
        } else{
          stor[[i]] <- "yes"
        }
      }
    }
  }   
  return(stor)
}

primecheck(len_t = 5, n = c(23, 13, 20, 1000, 99991))
```

# 25 - Ship and ID

Write a program that takes in a letterclass ID of a ship and display the equivalent string class description of the given ID. Use the table below.

* CLass ID: B or b, C or c, D or d, F or f; Ship Class: Battleship, Cruiser, Destroyer, Frigate.

* Input: The first line contains an integer T, the total number of test cases. Then T lines follow, each line contains a character.

* Output: For each test case, display the Ship Class depending on ID, in a new line.

* Constraints: 1 ≤ T ≤ 1000
```{r}
shipid <- function(len_t, n){
  stopifnot(len_t >= 1, len_t <= 1000)
  stor <- list()
  for(i in 1:len_t){
    if(n[i] == "B" | n[i] == "b"){
      stor[[i]] <- "Battleship"
    } else if(n[i] == "C" | n[i] == "c"){
      stor[[i]] <- "Cruiser"
    } else if(n[i] == "D" | n[i] == "d"){
      stor[[i]] <- "Destroyer"
    } else if(n[i] == "F" | n[i] == "f"){
      stor[[i]] <- "Frigate"
    } else{
      stop(paste("Incorrect input for:", n[i]))
    }
  }
  return(stor)
}

shipid(len_t = 3, n = c("B", "c", "D"))
```

# 25 - Puppy and Sum

Yesterday, puppy Tuzik learned a magically efficient method to find the sum of the integers from 1 to N. He denotes it as sum(N). But today, as a true explorer, he defined his own new function: sum(D, N), which means the operation sum applied D times: the first time to N, and each subsequent time to the result of the previous operation.

For example, if D = 2 and N = 3, then sum(2, 3) equals to sum(sum(3)) = sum(1 + 2 + 3) = sum(6) = 21.

Tuzik wants to calculate some values of the sum(D, N) function. Will you help him with that?

* Input: The first line contains a single integer T, the number of test cases. Each test case is described by a single line containing two integers D and N.

* Output: For each test case, output one integer on a separate line.

* Constraints: 1 ≤ T ≤ 16, 1 ≤ D, N ≤ 4
```{r}
puppysum <- function(len_t, d, n){
  stopifnot(len_t >= 1, len_t <= 16, d >= 1, n <= 4)
  x <- numeric()
  for(i in 1:len_t){
    if(d[i] == 1){
      x[i] <- sum(1:n[i])
    } else {
      x[i] <- n[i] 
      for(j in d){ #since the d vector can contain multiple numbers, only the number that is entering the for loop after the else statement will be used. So, if d[i] = 1, then it will stay one; but if d[i] == 2, then it will run the for loop after the else statement 2 times, until d becomes 0.
      while(d[i] > 0){
      x[i] <- sum(1:max(x[i]))
      d[i] <- d[i] - 1
      }
    }
  }
}
  return(x)
}

puppysum(len_t = 2, d = c(1, 2), n = c(4, 3))
```

# 26 - GCD and LCM

Two integers A and B are the inputs. Write a program to find GCD and LCM of A and B.

* Input: The first line contains an integer T, total number of testcases. Then follow T lines, each line contains an integer A and B.

* Output: Display the GCD and LCM of A and B separated by space respectively. The answer for each test case must be displayed in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ A,B ≤ 1000000
```{r}
gcdlcm <- function(len_t, a, b){
  stopifnot(len_t >= 1, len_t <= 1000, a >= 1, b >= 1, a <= 1000000, b <= 1000000)
  gcd <- numeric()
  lcm <- numeric()
  for(i in 1:len_t){
  if(a[i] > b[i]) {
  smaller <- b[i]
} else {
  smaller <- a[i]
} 
    for(j in 1:smaller){
    if(a[i] %% j == 0 & b[i] %% j == 0){
    gcd[i] <- j
    }
  }
  lcm[i] <- ((a[i] %/% gcd[i]) * (b[i] %/% gcd[i]) * gcd[i])
  }
  return(data.frame(gcd, lcm))
}  

gcdlcm(len_t = 3, a = c(120, 10213, 10), b = c(140, 312, 30))
```

# 27 - Total Expenses

While purchasing certain items, a discount of 10% is offered if the quantity purchased is more than 1000. If the quantity and price per item are input, write a program to calculate the total expenses.

* Input: The first line contains an integer T, total number of test cases. Then follow T lines, each line contains integers quantity and price.

* Output: For each test case, output the total expenses while purchasing items, in a new line.

* Constraints: 1 ≤ T ≤ 1000, 1 ≤ quantity,price ≤ 100000
```{r}
totalexp <- function(len_t, q, p){
  stopifnot(len_t >= 1, len_t <= 1000, q >= 1, p >= 1, q <= 100000, p <= 100000)
  stor <- list()
  for(i in 1:len_t){
    if(q[i] > 1000){
      stor[[i]] <- (q[i]*p[i]) - (.10*(q[i]*p[i]))
    } else{
      stor[[i]] <- (q[i]*p[i])
    }
  }
  return(stor)
}

totalexp(len_t = 3, q = c(100, 10, 1200), p = c(120, 20, 20))
```

# 28 - Fit Squares in Triangle